== ACME Music Player - Architecture Playground

image::.github/badges/jacoco.svg[Line Coverage]
image::.github/badges/branches.svg[Branch Coverage]

== Was ist das hier? 🧪

Eine **Spielwiese für Architektur-Experimente** - ein minimal lauffähiger Prototyp eines Musikplayers, der als Testbed für moderne Software-Architektur-Patterns dient.

*Warum ein Musikplayer?* Weil er genug fachliche Komplexität bietet, um realistische Architektur-Entscheidungen zu treffen, aber einfach genug bleibt, um sich auf die technischen Aspekte zu konzentrieren.

**Experimenteller Rahmen:**
* Minimal lauffähiger Prototyp mit etwas Funktionalität
* Modulith mit 3 Komponenten (Users, Musicplayer, Scoreboard)
* Labor für Architektur-Patterns und Testing-Strategien
* Dokumentation von Erkenntnissen und gescheiterten Ansätzen

== Evaluierte Architektur-Patterns ✅

=== Erfolgreich implementiert & validiert:

* **🏗️ Modulith-Architektur** - Monolithische Anwendung mit klaren Modul-Grenzen
* **🔄 Event-Driven Design** - Lose gekoppelte Kommunikation zwischen Komponenten
* **🧪 Clean Architecture** - Klare Trennung von Domain, Use Cases und Adaptern
* **⚡ Paralleles Testing** - Tenant-basierte Isolation für schnelle, unabhängige Tests
* **🥒 Cucumber Component-Tests** - BDD-Tests mit Fake Adapters statt klassischer Unit-Tests
* **📊 JOOQ-basierte Persistierung** - Type-safe SQL ohne JPA/Hibernate
* **🌐 HTMX + SSE Frontend** - Moderne Web-UI ohne JavaScript-Framework

=== Verworfene Ansätze (mit Learnings):

* **❌ Spring Native** - Zu unreif, siehe xref:documentation/ADRs/01-spring-native.adoc[ADR Spring Native]



=== Features

❓ = Geplant | ❌ = Verworfen | ✅ = Implementiert

* **3 Module/Komponenten in einem Modulithen** ✅
** **Users:** Registrierung und Fake-Login
** **Musicplayer:** MP3 hochladen, auflisten, abspielen
** **Scoreboard:** Auszeichnung für aktivste Nutzer
* **Cucumber-basierte** xref:documentation/componenttesting.adoc[Komponententests] ✅
* **Datenbankmigration mit Liquibase** ✅
* **Java Modell-Generierung mittels JOOQ** ✅
* **Maximal parallele, unabhängige Tests** ✅
* **Event Driven Architecture** ✅
* **HTMX Frontend mit SSE** ✅

== Schnellstart

[source,bash]
--
# Voraussetzungen: Java 21, Docker
sdk install java 21.0.2-tem && sdk use java 21.0.2-tem

# Datenbank aufsetzen und Tests laufen lassen
./mvnw clean test

# Anwendung starten
./mvnw docker-compose:up@run-docker
./mvnw spring-boot:run
--

Ausführliche Anleitung: xref:documentation/quickstart.adoc[→ Quickstart Guide]

== Laufende Experimente & Erkenntnisse

=== ✅ Abgeschlossene Experimente

==== Paralleles Testing durch Tenant-Isolation
**Status:** Erfolgreich implementiert

**Problem:** Langsame, sequentielle Integrationstests durch Datenbankreinigung
**Lösung:** Tenant-Parameter in allen Use Cases und Repositories
**Ergebnis:** Alle Tests können parallel in eigenen "Tenants" arbeiten

.Implementierung:
. UUID am Szenarioanfang im Test
. Alle Use Case Commands um "Tenant" Parameter erweitern (Default "1" oder "GLOBAL")
. Repos/Indizes nach Tenant-Id umbauen
. AfterAll: Löschen aller Testdaten anhand des Tenants

==== Modulith-Architektur
**Status:** Erfolgreich validiert

**Erkenntnisse:**
* Test-zu-Test Kommunikation via Fake Events funktioniert ausgezeichnet
* Klare Modul-Grenzen ohne Microservice-Overhead
* ArchUnit verhindert unerlaubte Abhängigkeiten zwischen Modulen

.Überlegungen für Microservice-Migration:
* Use Case-Rückgaben werden zu DTOs
* "Extra-Logik" findet automatisch bei DTO-Umwandlung statt
* Event-getriebene Kommunikation bleibt unverändert

=== ❓ Laufende Experimente

==== Testdaten in komplexen Fachprozessen
**Problem:** Wie können Tests am Ende komplexer fachlicher Prozesse geschrieben werden?

**Ansätze in Evaluation:**

. **Fachlich korrekte Testdatenbuilder**
   * ⚠️ Gefahr der Re-Implementierung der Businesslogik im Testcode
   * ✅ Wiederverwendung von Businesslogik möglich
   * ❌ Erzwingt Datenbankzugriff an Use Cases vorbei

. **Snapshot/Backup-Restore für Szenarien**
   * ✅ Szenario 1 laufen lassen → snapshotted → in Szenario 2 wiederverwenden
   * ❌ Abhängigkeiten zwischen Szenarien entstehen

. **Prozessorientierte Testszenarien**
   * Statt einzelner Features: komplette User-Journeys testen
   * Beispiel: "User registriert sich → lädt MP3 hoch → spielt ab" in einem Szenario

==== Ideen für zukünftige Experimente
* **Commands Pattern** ❓
* **Event-Bibliothek mit Inbox/Outbox Pattern** ❓
* **Automatische Event-Dokumentation** ❓
* **Prozess-Visualisierung** ❓

== Architektur & Design

=== System-Überblick
image::acme-aufbau.drawio.png[ACME Systemaufbau,100%]

=== Test-Strategie Innovation
**Besonderheit:** ACME hat keine klassischen Unit-Tests, sondern ausschließlich **Komponententests** mit sehr hoher Testabdeckung!

Detaillierte Erklärung: xref:documentation/componenttesting.adoc[→ Component Testing Konzept]

=== Technologie-Stack

**Backend:**

* Java 21  
* Spring Boot 3.x
* JOOQ (statt JPA/Hibernate)
* PostgreSQL
* Liquibase

**Testing:**

* Cucumber (Component Tests)
* JUnit 5 (Integration Tests)
* Playwright (E2E Tests)

**Frontend:**

* HTMX
* Halfmoon CSS
* Server Sent Events (SSE)

**Infrastructure:**

* Docker & Docker Compose
* Maven Multi-Module

== Weitere Dokumentation

=== Architektur & Entscheidungen
* xref:documentation/ADRs/adrs.adoc[📋 Architecture Decision Records (ADRs)]
* xref:documentation/componenttesting.adoc[🧪 Component Testing Strategie]
* xref:documentation/quickstart.adoc[🚀 Quickstart & Setup Guide]

=== Erkenntnisse aus Experimenten
* xref:documentation/ADRs/01-spring-native.adoc[Spring Native Evaluation] - Warum wir es verworfen haben
* xref:documentation/ADRs/02-testing-framework.adoc[Testing Framework Vergleich] - Cucumber vs. JUnit vs. Spock
* xref:documentation/ADRs/03-persistenzframework.adoc[Persistenz-Framework Entscheidung] - JOOQ vs. JPA

---

💡 **Für Entwickler:** Dieses Projekt ist bewusst als Experimentierfeld konzipiert. Erkenntnisse, gescheiterte Ansätze und Learnings sind genauso wertvoll wie funktionierende Lösungen!
