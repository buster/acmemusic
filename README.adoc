== ACME Music Player - Architecture Playground

image::.github/badges/jacoco.svg[Line Coverage]
image::.github/badges/branches.svg[Branch Coverage]

== Was ist das hier? ğŸ§ª

Eine **Spielwiese fÃ¼r Architektur-Experimente** - ein minimal lauffÃ¤higer Prototyp eines Musikplayers, der als Testbed fÃ¼r moderne Software-Architektur-Patterns dient.

=== Der Prototyp

**Was der Musikplayer macht:**

* **Benutzerregistrierung**: Neue Benutzer kÃ¶nnen sich registrieren und werden automatisch eingeloggt (kein expliziter Login/Logout-Prozess)
* **MP3-Upload & Wiedergabe**: Benutzer kÃ¶nnen MP3-Dateien hochladen und abspielen
* **Live-Scoreboard**: Benutzer erhalten Echtzeit-Benachrichtigungen (via Server-Sent Events), wenn jemand zum Top-Scorer wird

**Architektur-Demonstration:**

Der Prototyp zeigt das **Zusammenspiel von 3 Komponenten** Ã¼ber Events in einem **Modulithen**:

* **ğŸ‘¤ User-Komponente**: Registrierung, automatischer Login, Event-Empfang via SSE
* **ğŸµ Musicplayer-Komponente**: MP3-Upload, Wiedergabe, sendet "NeuesLiedWurdeAngelegt" Events
* **ğŸ† Scoreboard-Komponente**: ZÃ¤hlt Lieder pro User, ermittelt Top-Scorer, sendet "BenutzerIstNeuerTopScorer" Events

*Warum ein Musikplayer?* Genug fachliche KomplexitÃ¤t fÃ¼r realistische Architektur-Entscheidungen, aber einfach genug, um sich auf die technischen Aspekte zu konzentrieren.

**Experimenteller Rahmen:**
* Minimal lauffÃ¤higer Prototyp mit ausreichend Logik fÃ¼r Experimente
* Labor fÃ¼r Architektur-Patterns und Testing-Strategien
* Dokumentation von Erkenntnissen und gescheiterten AnsÃ¤tzen

== Architektur-Highlights âœ…

* **ğŸ—ï¸ Modulith mit Event-Driven Design** - 3 lose gekoppelte Komponenten Ã¼ber Events
* **ğŸ§ª Clean Architecture** - Domain, Use Cases, Adapters klar getrennt
* **ğŸ¥’ Component-Testing statt Unit-Tests** - Cucumber BDD-Tests mit Fake Adapters
* **âš¡ Parallele Tests** - Tenant-basierte Isolation ohne Datenbankreinigung

=== Technologie-Stack

**Backend:** Java 21, Spring Boot 3.x, JOOQ, PostgreSQL, Liquibase
**Testing:** Cucumber (Component Tests), JUnit 5 (Integration Tests), Playwright (E2E Tests)
**Frontend:** HTMX, Halfmoon CSS, Server-Sent Events (SSE)
**Build:** Maven Multi-Module, Docker & Docker Compose

== Schnellstart

[source,bash]
--
# Voraussetzungen: Java 21, Docker
sdk install java 21.0.2-tem && sdk use java 21.0.2-tem

# Datenbank aufsetzen und Tests laufen lassen
./mvnw clean verify

# Anwendung starten
./mvnw docker-compose:up@run-docker -pl services/acme
./mvnw spring-boot:run -pl services/acme
--

AusfÃ¼hrliche Anleitung: xref:documentation/development-setup.adoc[â†’ Development Setup Guide]

== Laufende Experimente & Erkenntnisse

=== âœ… Abgeschlossene Experimente

==== Paralleles Testing durch Tenant-Isolation

**Status:** Erfolgreich implementiert

**Problem:** Langsame, sequentielle Integrationstests durch Datenbankreinigung
**LÃ¶sung:** Tenant-Parameter in allen Use Cases und Repositories
**Ergebnis:** Alle Tests kÃ¶nnen parallel in eigenen "Tenants" arbeiten

.Implementierung:
. UUID am Szenarioanfang im Test
. Alle Use Case Commands um "Tenant" Parameter erweitern (Default "1" oder "GLOBAL")
. Repos/Indizes nach Tenant-Id umbauen
. AfterAll: LÃ¶schen aller Testdaten anhand des Tenants

==== Event-Driven Modulith

**âœ… Validiert:** Fake Events fÃ¼r Test-zu-Test Kommunikation, klare Modul-Grenzen ohne Microservice-Overhead, ArchUnit verhindert unerlaubte AbhÃ¤ngigkeiten.

**Migration zu Microservices:** Use Cases â†’ DTOs, Event-Kommunikation bleibt unverÃ¤ndert.

=== â“ Laufende Experimente

==== Testdaten in komplexen Fachprozessen

**Problem:** Wie kÃ¶nnen Tests am Ende komplexer fachlicher Prozesse geschrieben werden?

**AnsÃ¤tze in Evaluation:**

. **Fachlich korrekte Testdatenbuilder**
* âš ï¸ Gefahr der Re-Implementierung der Businesslogik im Testcode
* âœ… Wiederverwendung von Businesslogik mÃ¶glich
* âŒ Erzwingt Datenbankzugriff an Use Cases vorbei

. **Snapshot/Backup-Restore fÃ¼r Szenarien**
* âœ… Szenario 1 laufen lassen â†’ snapshotted â†’ in Szenario 2 wiederverwenden
* âŒ AbhÃ¤ngigkeiten zwischen Szenarien entstehen

. **Prozessorientierte Testszenarien**
* Statt einzelner Features: komplette User-Journeys testen
* Beispiel: "User registriert sich â†’ lÃ¤dt MP3 hoch â†’ spielt ab" in einem Szenario

==== Weitere Experiment-Ideen
* Command Pattern, automatische Event-Dokumentation, Prozess-Visualisierung

== Architektur & Design

=== System-Ãœberblick & Test-Strategie

image::acme-aufbau.drawio.png[ACME Systemaufbau,100%]

**Test-Innovation:** Keine klassischen Unit-Tests, sondern **Komponententests** mit hoher Abdeckung!
Details: xref:documentation/componenttesting.adoc[â†’ Component Testing Konzept]

=== Evaluierte Technologien

**âœ… Erfolgreich implementiert:**
* **JOOQ** statt JPA/Hibernate - Type-safe SQL ohne ORM-Overhead
* **Cucumber Component-Tests** statt klassischer Unit-Tests - BDD-Tests mit Fake Adapters
* **Tenant-basierte Test-Isolation** - Parallele, unabhÃ¤ngige Tests ohne Datenbankreinigung
* **HTMX + SSE** - Moderne Web-UI ohne JavaScript-Framework

**âŒ Verworfene AnsÃ¤tze:** Spring Native (zu unreif, siehe xref:documentation/ADRs/01-spring-native.adoc[ADR])

== Weitere Dokumentation

* xref:documentation/development-setup.adoc[ğŸš€ Setup Guide] - AusfÃ¼hrliche Entwicklungsumgebung
* xref:documentation/componenttesting.adoc[ğŸ§ª Component Testing] - Testing-Strategie im Detail
* xref:documentation/ADRs/adrs.adoc[ğŸ“‹ Architecture Decision Records] - Alle Architektur-Entscheidungen

=== Erkenntnisse aus Experimenten

* xref:documentation/ADRs/01-spring-native.adoc[Spring Native Evaluation] - Warum wir es verworfen haben
* xref:documentation/ADRs/02-testing-framework.adoc[Testing Framework Vergleich] - Cucumber vs.
JUnit vs.
Spock
* xref:documentation/ADRs/03-persistenzframework.adoc[Persistenz-Framework Entscheidung] - JOOQ vs.
JPA

'''

ğŸ’¡ **FÃ¼r Entwickler:** Dieses Projekt ist bewusst als Experimentierfeld konzipiert.
Erkenntnisse, gescheiterte AnsÃ¤tze und Learnings sind genauso wertvoll wie funktionierende LÃ¶sungen!
